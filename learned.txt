Atcoder Problems:https://kenkoooo.com/atcoder/#/table/


やったこと(やる予定のこと)：
過去問演習：332, 333
精選など：ABS, https://qiita.com/drken/items/fd4e5e3630d0f5859067


学んだこと：
全体：
pythonの場合，1秒は10^7オーダまで．つまり，N<=10^3ならO(N^2)までOK, N<=10^4ならO(N)まで．

ABS：
PracticeA, printがa bの場合は，printをend=" "にする．空白を忘れないように．
ABC081B, 出力などに利用する文字はiなどを使わない．ループの変数と被る．
ABC083B, 変数にsumなどの標準関数名を使わない．sum(list)が変数として処理される．
ABC088B, 明らかに正解でもsampleぐらいはチェックすること．
ABC088B, listのスライス第三引数は2で一つ飛ばし．
ABC085C, 3変数の全探索O(N^3)をする場合，条件が二つあれば，片方の条件を使って三つ目の変数はbindされる．よってO(N^2)でよい．
ABC085C, 全探索のTLEの障害は，上記bindや，方程式を解くことによる条件の絞り込みでオーダを減らす．
ABC049C, 後ろからの貪欲法などは文字列の場合re.subで後ろから削除する方法で実装できる．しかし，re.subが遅いのでキューの考え方でlastを動かした方が良い．
ABC086C, ランダムウォーク系の問題の一部は，偶数/奇数だけ確認すればよいこともある(パリティの考え方)

ABS_Simi
ABC088C, 仮定を置いてみることが大事．制約も条件もない変数があれば，その変数に関する探索はしなくてよいのではと疑う．
ABC096C, 定式化を整理することがかなり大事かも．仮定も大事．
ABC112C, もし一部だけWAでコーナーケースが疑われたら，探索範囲を少しだけ広げてみてもよい．
AGC013A, REはlist index out of rangeを気にする．
ABC093C, list.count(ele), 仮定はやっぱり大事．
AGC011A, 順番に与えられるモノがソートされているという前提があるかどうか確認する．
AGC010A, 仮定を得るためには，実験が大事．
ABC059C, 条件を勘違いしないように．1回の操作で1項を1か+1変更できる→1項につき1回までしか触れないわけではない．

ABS_Plus
ABC075B, グリッド問題であるグリッドの八方を見る場合，グリッドを拡張して添字に気を遣う方法と，list index outなら0を返し，
    そうでないなら要素を返す関数を実装する方法がある．前者は添字が面倒だが計算量が少ない?ので．本プログラムを見ていけそうなら前者にする．
ABC055B, 割った余りを答える問題は，計算の途中で余りをとって良いか考える
ABC048B, オーバーフローにも気をつける．1e18ぐらいでアウト．b-aではなくb/x-a/xとかにすると回避可能？pythonにオーバーフローはないらしいが怪しい．
ABC065B, 計算量への対策は，一般的には工夫することで全探索をしないようにする．なお，反対に，全探索が単純な処理で，かつ工夫の内容がappendやinを使ったものならば，
    逆に全探索してしまった方がいいこともある．なお，この時は，推移性などを使うことが多い．
ABC046B, 色塗りは端から決めていく考え方が有効．
ABC079C, bit全探索は，2^NのNが小さければ，N重ループで解決可能．とは行っても，書くのがめんどくさいだけで，計算量が増えているわけではない．

332回：
c, 合計の日数とかから考えても良い
c, 条件を文字にしてみるとわかりやすい
d, 入れ替え問題は転倒数に帰着

333回：
b, 一部がWAの時は，コーナーケースを考える
c, 直感的な仮定を置いてみる
d, 累積和を求めて比較する問題は，累積和の数列を二分探索
d, クエリが複数与えられ，出力も複数出すものは，答えを残しておいてまとめて出力する．クエリごとに出力はWAとなる．

便利tips:
累積和：from itertools import accumulate, A=list, list(accumulate(A))
直積，順列，組み合わせ：from itertools import product, permutations,combinations product(A, 2)など
緩和二分探索？(bisearch.py)：from bisect import bisect_left,bisect bisect(L,12)など
最大公約数：from fractions import gcd gcd(1,4)
リストのカウント：list.count(ele), from collections import Counter(list) なら多い順に得られる

その他URL：
様々な関数や書き方：https://qiita.com/y-tsutsu/items/aa7e8e809d6ac167d6a1
便利ライブラリ：https://qiita.com/Kentaro_okumura/items/5b95b767a2e691cd5482