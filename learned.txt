Atcoder Problems:https://kenkoooo.com/atcoder/#/table/


やったこと
過去問演習：332, 333
精選など：ABS, ABS類題(https://qiita.com/drken/items/fd4e5e3630d0f5859067)


学んだこと
全体：
pythonの場合，1秒は10^7オーダまで．つまり，N<=10^3ならO(N^2)までOK, N<=10^4ならO(N)まで．

以降，問題の前に*がついているものは，考え方がわかったけど実装が大変そうすぎてやっていないもの．

ABS
PracticeA, printがa bの場合は，printをend=" "にする．空白を忘れないように．
ABC081B, 出力などに利用する文字はiなどを使わない．ループの変数と被る．
ABC083B, 変数にsumなどの標準関数名を使わない．sum(list)が変数として処理される．
ABC088B, 明らかに正解でもsampleぐらいはチェックすること．
ABC088B, listのスライス第三引数は2で一つ飛ばし．
ABC085C, 3変数の全探索O(N^3)をする場合，条件が二つあれば，片方の条件を使って三つ目の変数はbindされる．よってO(N^2)でよい．
ABC085C, 全探索のTLEの障害は，上記bindや，方程式を解くことによる条件の絞り込みでオーダを減らす．
ABC049C, 後ろからの貪欲法などは文字列の場合re.subで後ろから削除する方法で実装できる．しかし，re.subが遅いのでキューの考え方でlastを動かした方が良い．
ABC086C, ランダムウォーク系の問題の一部は，偶数/奇数だけ確認すればよいこともある(パリティの考え方)

ABS_Simi
ABC088C, 仮定を置いてみることが大事．制約も条件もない変数があれば，その変数に関する探索はしなくてよいのではと疑う．
ABC096C, 定式化を整理することがかなり大事かも．仮定も大事．
ABC112C, もし一部だけWAでコーナーケースが疑われたら，探索範囲を少しだけ広げてみてもよい．
AGC013A, REはlist index out of rangeを気にする．
ABC093C, list.count(ele), 仮定はやっぱり大事．
AGC011A, 順番に与えられるモノがソートされているという前提があるかどうか確認する．
AGC010A, 仮定を得るためには，実験が大事．
ABC059C, 条件を勘違いしないように．1回の操作で1項を1か+1変更できる→1項につき1回までしか触れないわけではない．

ABS_Plus
ABC075B, グリッド問題であるグリッドの八方を見る場合，グリッドを拡張して添字に気を遣う方法と，list index outなら0を返し，
    そうでないなら要素を返す関数を実装する方法がある．前者は添字が面倒だが計算量が少ない?ので．本プログラムを見ていけそうなら前者にする．
ABC055B, 割った余りを答える問題は，計算の途中で余りをとって良いか考える
ABC048B, オーバーフローにも気をつける．1e18ぐらいでアウト．b-aではなくb/x-a/xとかにすると回避可能？pythonにオーバーフローはないらしいが怪しい．
ABC065B, 計算量への対策は，一般的には工夫することで全探索をしないようにする．なお，反対に，全探索が単純な処理で，かつ工夫の内容がappendやinを使ったものならば，
    逆に全探索してしまった方がいいこともある．なお，この時は，推移性などを使うことが多い．
ABC046B, 色塗りは端から決めていく考え方が有効．
ABC079C, bit全探索は，2^NのNが小さければ，N重ループで解決可能．とは行っても，書くのがめんどくさいだけで，計算量が増えているわけではない．
ABC087C, C問題でも，N<100などなら全探索してしまってよい．しかし，DPの方が考え方が簡単なこともある．
ABC096C, YESなのかYesなのかはちゃんと確認．実験大事．

339
特になし

338
a, チェックする．
c, 数理最適化のような問題が出てきたら，メモ帳に定式化と最大化する目標の値を書き込むのも有効．アイデアが湧きやすく，制約が間に合うかも判断しやすい．

337
c, リストの配列で数珠繋ぎに見ていくときは，indexは使わない．なぜならO(n^2)になるから．(indexがO(n)だから)
    よって，リストの内容を辞書順にしておくとO(1)なのでよい．
d, 問題を分割し，実装していくやり方が有効な時もある．考え方として．可能かどうかの判定を実装し，うまくいったら，可能な時に対応する数値を出す，のような方法でもわかりやすい．
d, 累積和は大事．
e, n個ある中から，1つのものを特定したい状況を仮定する時，対象がそれかどうかが2値であれば，判定機はceil(log2N)あればよい．判定機は複数判定でき，時系列はt=1のみとする．

336
c, x個の数字のみを使う=x進数を言い換えられる．np.base_repr(int, base)
オンライム参加感想：d問題は無理で，やっぱり緑だった．

335
c, queryが10^5近くある時は，そのそれぞれに対してsumを求めるのはTLE．やらなくてもわかるのでやらない．時間の無駄．実装の実装のイメージができないときはOK
d, 二重ループが離れているときは，同じ文字を使わないように．
d, if ~~ elif ~~     else の時は，elifがFalseの時，elifに行かないので注意
d, 配列の中身をチェックしたい時，index外を気にするなら，関数を作成する．二重ifを使うと上記問題が発生しやすい．単純にif文も複雑になる．
d, 二次元リストを回りながら更新するときは，リストの添字ではなく，iなどの入れる中身をforにする．また，リストないの位置ではなく，方向を保存しておく方法がよい．
オンタイム参加感想：時間が足りなかった&グリッド問題の実装が，実現のためのアイデアの2倍くらい難しかった．

333
b, 一部がWAの時は，コーナーケースを考える
c, 直感的な仮定を置いてみる
d, 累積和を求めて比較する問題は，累積和の数列を二分探索
d, クエリが複数与えられ，出力も複数出すものは，答えを残しておいてまとめて出力する．クエリごとに出力はWAとなる．

332
c, 合計の日数とかから考えても良い
c, 条件を文字にしてみるとわかりやすい
d, 入れ替え問題は転倒数に帰着

331
c, 累積和などの考え方は，ライブラリの使い方を覚えるのではなく，考え方を理解する．
c, 自分より大きい値の和を求める際には，リストを逆順にして累積和を考える．
c, リストをソートし，元の配列からソート済みへのindexを得ることはO(N)ではおそらく不可能．ソート済みから元の配列へのindexはタプルのソートでO(N)で可能．
c, 配列を空白を入れて出力したい時は，print(*answer)のようにすればよい．

330
c, xyの組を判定するだけなら，x<=yとしても一般性は失わない
d, ある操作をしたエンティティを何度も扱うなら，操作したものを別で保存しておき，それを利用する．毎回操作をしない．
    特に，リスト内包表記だと，何度も扱っていることを忘れがちなので注意．
d, 2項組などを考える際，片方を固定すると，もう片方に意識が集中してしまう．固定した方の条件などを書き忘れていないか注意する．

329
a, 配列を空白を入れて出力するとき，*list(string)にするとREが出る．ターミナルでは動く．*(list(string))のようにカッコで囲む．
d, TLEになった時は，計算量のオーダだけでなく，不必要な二次元配列を持っていないか確認する．現在の状況を任意のt全てでなく，現在のtだけで持っていればよく，更新していけばよいなど．
    オーダが大きそうに見えなくても，大きな配列にアクセスしているだけで実行時間は増加する．

328
c, 累積和にはちゃんと気づき，accumulateを使う．
c, ある配列における特定区間中のsumを何度も求めるときは，累積和を使ってsums[r]-sums[l]とする．
d, 配列を前から順に見ていく場合，簡単にTLEと判断しないこと．ABCBCBABCABからABCを削除してく場合，スタックを使えばO(N)でいける．

327
a, 0**0 = 1に注意．コーナーケース
*d, 0と1の二つのグループに分けることは思いついていた．二部グラフの知識がなかったので覚えておく．二部グラフの判定は，異なる数字となるものがない時点でNGを出せば良いので，深さ優先探索で行う．

326
c, 二分探索の計算量はlognであるので，nのループの中で回せばnlognとなる．さらに，nlognは想像以上に小さいので注意．
c, 配列の要素を見ていき，，ある数mを超えるところまでカウントしていく作業は二分探索で可能．カウントではなく，要素を足したいなら二分探索の後にsumが必要．

325
c, グリッド上のエンティティが繋がっているかを判定するときは，しっかりと四方(八方)を見る必要がある．for文の伝播だけ考えて，左上だけ見ればいいわけではない．
    なぜなら，Uの字のようになっている時があるから．幅(深さ)優先探索が必要
c, 幅優先探索はdequeをキューとして，深さ優先探索はdequeをスタックとして利用する．
c, 探索でuniqueの種類を求める時は，探索済フラグを管理しておけば，indexを+1していき，indexを出力すればよい．ANSにすべて書き込み，maxをとる必要はない．
c, 幅・深さ優先探索のとき，対象が木構造であれば探索済みかどうかは保持する必要はないが，グリッドだと保持する必要がある．
    この場合，探索済みかどうかを配列で確認するとなんども無駄なデータがエンキューされ，計算量の問題が生じる．これは，キューの内容を判定してからその配列を更新するまでにラグがあり，その間にエンキューされるため．
    これを防ぐためには，エンキューした瞬間にset(done)などに記録していく必要がある．

324
c, 一文字削除or追加or置換なので，編集距離の問題だった．
c, ある配列を1文字削除or追加or置換する問題は，二つの文字列に関して，前からの文字の一致数と後ろからの一致数を考えればよい．
c, 長い文字列に限らず，何度も意味のない変換をしないこと．何度も呼び出される関数の中で，事前に行っておける定数キャストをするなどは絶対NG．それで8倍以上の実行時間がかかっていた．

323
c, 全員の特典を上回る=自分が1位かつ1位が1人なら0点必要，それ以外なら+1必要
c, 得点を充足していく系は，低い得点のものから優先的に選ぶのか，そうでないのか確認．前者ならaccumulate, 後者なら後ろから見ていけば良い．
c, 同じく充足系は，すでに解いた問題はもう解けない=点数を増やせないので，そこを確認すること．

322
特になし

321
a, どんな時でも落ち着いて，テストケースを試すのを忘れないようにする．無駄にWAでペナルティをもらってしまう．

320
b, pythonのスライスは，[::-1]のように逆順を指定すると，[start:stop:]ではなく，[start:stop:]となるので注意．
b, 文字列が回文であるかは，以下のプログラムで判定可能．
    long = len(sub)     if sub[:long//2] == sub[:long//2-1+(long%2):-1]:
c, 一見複雑そうに見える問題は，変数や探索の順番を固定する=ループで回すことで，簡単に判定ができることがある．この場合，判定が簡単だと，ループでオーダが増えても間に合うことが多い．

便利tips:
累積和：from itertools import accumulate list(accumulate(A))
直積，順列，組み合わせ：from itertools import product, permutations,combinations product(A, 2)など
緩和二分探索？(bisearch.py)：from bisect import bisect_left,bisect bisect(L,12)など．leftなら，ないときは挿入添字．あるときはそれらの最も左添え字を返す．
最大公約数：from fractions import gcd gcd(1,4)
リストのカウント：list.count(ele), from collections import Counter(list) なら多い順に得られる
キュー・スタック・双方向の実装：from collections import deque として，pop, popleft, append, appendleftを利用する．
転置：S = np.array(S).T.tolist()

リストの初期化：
一次元：a = [0]*5 
二次元：a = [[0]*3 for i in range(5)]

リストのコピー：
一次元：b = a[:], b=aはNG
二次元：import copy, b = copy.deepcopy(a)

input：
n=int(input())
a,b=map(int, input().split())
c=list(map(int, input().split()))
s=[list(map(int,list(input()))) for i in range(h)], listの前後に[]をつけると[[[1,2,3]], [[1,2,3]]]のように3次元になる．

計算量の基準：
C言語とすると，2sectで2*10e7~8である．以下に，計算量とその場合に許容できるnの値を示す．
重要なのが，lognは想像以上に小さくなること．
n!...n=10程度
2**n...n=20程度
2**n/2...n=30程度
n**4...n=100程度
n**3...n=300程度
n**2...n=10**3~4程度
nlogn...n=10**5~6程度
n...n=10**7~8程度
logn...n=10**9~12程度

提出環境について：
mambaforge, CPython, Cython, PyPy, SageMathの4つがあるが，基本はPyPyで出す．
今まで使っていたmambaforgeと比較して，PyPyの方が10倍以上早くなることもある．
ただし，PyPyは再帰関数と外部ライブラリの読み込み，decimalが非常に遅いので，特に再帰関数を多用する時はCPythonを使うか，普段からCPythonにしておいて，遅い時だけPyPyにする．

アルゴリズムの計算量：
二分探索 logn
ソート　nlogn

その他URL：
様々な関数や書き方：https://qiita.com/y-tsutsu/items/aa7e8e809d6ac167d6a1
便利ライブラリ：https://qiita.com/Kentaro_okumura/items/5b95b767a2e691cd5482
計算量：https://qiita.com/Hironsan/items/68161ee16b1c9d7b25fb