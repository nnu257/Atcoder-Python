Atcoder Problems:https://kenkoooo.com/atcoder/#/table/


やったこと
過去問演習：332, 333
精選など：ABS, ABS類題(https://qiita.com/drken/items/fd4e5e3630d0f5859067)


学んだこと
全体：
pythonの場合，1秒は10^7オーダまで．つまり，N<=10^3ならO(N^2)までOK, N<=10^4ならO(N)まで．

以降，問題の前に*がついているものは，考え方がわかったけど実装が大変そうすぎてやっていないもの．

ABS
PracticeA, printがa bの場合は，printをend=" "にする．空白を忘れないように．
ABC081B, 出力などに利用する文字はiなどを使わない．ループの変数と被る．
ABC083B, 変数にsumなどの標準関数名を使わない．sum(list)が変数として処理される．
ABC088B, 明らかに正解でもsampleぐらいはチェックすること．
ABC088B, listのスライス第三引数は2で一つ飛ばし．
ABC085C, 3変数の全探索O(N^3)をする場合，条件が二つあれば，片方の条件を使って三つ目の変数はbindされる．よってO(N^2)でよい．
ABC085C, 全探索のTLEの障害は，上記bindや，方程式を解くことによる条件の絞り込みでオーダを減らす．
ABC049C, 後ろからの貪欲法などは文字列の場合re.subで後ろから削除する方法で実装できる．しかし，re.subが遅いのでキューの考え方でlastを動かした方が良い．
ABC086C, ランダムウォーク系の問題の一部は，偶数/奇数だけ確認すればよいこともある(パリティの考え方)

ABS_Simi
ABC088C, 仮定を置いてみることが大事．制約も条件もない変数があれば，その変数に関する探索はしなくてよいのではと疑う．
ABC096C, 定式化を整理することがかなり大事かも．仮定も大事．
ABC112C, もし一部だけWAでコーナーケースが疑われたら，探索範囲を少しだけ広げてみてもよい．
AGC013A, REはlist index out of rangeを気にする．
ABC093C, list.count(ele), 仮定はやっぱり大事．
AGC011A, 順番に与えられるモノがソートされているという前提があるかどうか確認する．
AGC010A, 仮定を得るためには，実験が大事．
ABC059C, 条件を勘違いしないように．1回の操作で1項を1か+1変更できる→1項につき1回までしか触れないわけではない．

ABS_Plus
ABC075B, グリッド問題であるグリッドの八方を見る場合，グリッドを拡張して添字に気を遣う方法と，list index outなら0を返し，
    そうでないなら要素を返す関数を実装する方法がある．前者は添字が面倒だが計算量が少ない?ので．本プログラムを見ていけそうなら前者にする．
ABC055B, 割った余りを答える問題は，計算の途中で余りをとって良いか考える
ABC048B, オーバーフローにも気をつける．1e18ぐらいでアウト．b-aではなくb/x-a/xとかにすると回避可能？pythonにオーバーフローはないらしいが怪しい．
ABC065B, 計算量への対策は，一般的には工夫することで全探索をしないようにする．なお，反対に，全探索が単純な処理で，かつ工夫の内容がappendやinを使ったものならば，
    逆に全探索してしまった方がいいこともある．なお，この時は，推移性などを使うことが多い．
ABC046B, 色塗りは端から決めていく考え方が有効．
ABC079C, bit全探索は，2^NのNが小さければ，N重ループで解決可能．とは行っても，書くのがめんどくさいだけで，計算量が増えているわけではない．
ABC087C, C問題でも，N<100などなら全探索してしまってよい．しかし，DPの方が考え方が簡単なこともある．
ABC096C, YESなのかYesなのかはちゃんと確認．実験大事．

333
b, 一部がWAの時は，コーナーケースを考える
c, 直感的な仮定を置いてみる
d, 累積和を求めて比較する問題は，累積和の数列を二分探索
d, クエリが複数与えられ，出力も複数出すものは，答えを残しておいてまとめて出力する．クエリごとに出力はWAとなる．

332
c, 合計の日数とかから考えても良い
c, 条件を文字にしてみるとわかりやすい
d, 入れ替え問題は転倒数に帰着

331
c, 累積和などの考え方は，ライブラリの使い方を覚えるのではなく，考え方を理解する．
c, 自分より大きい値の和を求める際には，リストを逆順にして累積和を考える．
c, リストをソートし，元の配列からソート済みへのindexを得ることはO(N)ではおそらく不可能．ソート済みから元の配列へのindexはタプルのソートでO(N)で可能．
c, 配列を空白を入れて出力したい時は，print(*answer)のようにすればよい．

330
c, xyの組を判定するだけなら，x<=yとしても一般性は失わない
d, ある操作をしたエンティティを何度も扱うなら，操作したものを別で保存しておき，それを利用する．毎回操作をしない．
    特に，リスト内包表記だと，何度も扱っていることを忘れがちなので注意．
d, 2項組などを考える際，片方を固定すると，もう片方に意識が集中してしまう．固定した方の条件などを書き忘れていないか注意する．

329
a, 配列を空白を入れて出力するとき，*list(string)にするとREが出る．ターミナルでは動く．*(list(string))のようにカッコで囲む．
d, TLEになった時は，計算量のオーダだけでなく，不必要な二次元配列を持っていないか確認する．現在の状況を任意のt全てでなく，現在のtだけで持っていればよく，更新していけばよいなど．
    オーダが大きそうに見えなくても，大きな配列にアクセスしているだけで実行時間は増加する．

328
c, 累積和にはちゃんと気づき，accumulateを使う．
c, ある配列における特定区間中のsumを何度も求めるときは，累積和を使ってsums[r]-sums[l]とする．
d, 配列を前から順に見ていく場合，簡単にTLEと判断しないこと．ABCBCBABCABからABCを削除してく場合，スタックを使えばO(N)でいける．

327
a, 0**0 = 1に注意．コーナーケース
*d, 0と1の二つのグループに分けることは思いついていた．二部グラフの知識がなかったので覚えておく．二部グラフの判定は，異なる数字となるものがない時点でNGを出せば良いので，深さ優先探索で行う．

便利tips:
累積和：from itertools import accumulate, A=list, list(accumulate(A))
直積，順列，組み合わせ：from itertools import product, permutations,combinations product(A, 2)など
緩和二分探索？(bisearch.py)：from bisect import bisect_left,bisect bisect(L,12)など
最大公約数：from fractions import gcd gcd(1,4)
リストのカウント：list.count(ele), from collections import Counter(list) なら多い順に得られる

リストの初期化：
一次元：a = [0]*5 
二次元：a = [[0]*3 for i in range(5)]

リストのコピー：
一次元：b = a[:], b=aはNG
二次元：import copy, b = copy.deepcopy(a)

input：
n=int(input())
a,b=map(int, input().split())
c=list(map(int, input().split()))
s=[list(map(int,list(input()))) for i in range(h)], listの前後に[]をつけると[[[1,2,3]], [[1,2,3]]]のように3次元になる．


その他URL：
様々な関数や書き方：https://qiita.com/y-tsutsu/items/aa7e8e809d6ac167d6a1
便利ライブラリ：https://qiita.com/Kentaro_okumura/items/5b95b767a2e691cd5482
計算量：https://qiita.com/Hironsan/items/68161ee16b1c9d7b25fb